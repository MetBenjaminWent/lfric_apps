!-----------------------------------------------------------------------------
! (c) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Test the horizontal cubic semi-Lagrangian kernel

module horizontal_cubic_sl_sphere_kernel_mod_test

  use constants_mod, only : i_def, r_tran, r_def, IMDI

  implicit none

contains

  !------------------------------------------------------------------

  @Test
  subroutine horizontal_cubic_sl_sphere_kernel_test( )

    use, intrinsic :: iso_fortran_env,  only: real64
    use funit
    use horizontal_cubic_sl_sphere_kernel_mod, only: horizontal_cubic_sl_sphere_code
    use transport_enumerated_types_mod, only: monotone_none

    implicit none

    real(kind=r_tran), parameter :: tol = 1.0e-12_r_tran   ! r_tran 64-bit
    real(kind=r_tran)            :: answer, use_tol

    integer(kind=i_def), parameter :: nlayers = 1
    integer(kind=i_def), parameter :: ndf_wf = 1
    integer(kind=i_def), parameter :: ndf_w2 = 4
    integer(kind=i_def), parameter :: undf_w2 = ndf_w2*nlayers
    integer(kind=i_def), parameter :: ndf_pid = 1
    integer(kind=i_def), parameter :: undf_pid = 1

    integer(kind=i_def), dimension(ndf_wf)  :: map_wf
    integer(kind=i_def), dimension(ndf_w2)  :: map_w2
    integer(kind=i_def), dimension(ndf_pid) :: map_pid
    real(kind=r_tran),   dimension(undf_w2) :: dep_pts_xy

    real(kind=r_def),    dimension(undf_pid) :: panel_id
    integer(kind=i_def), dimension(undf_pid) :: panel_edge_dist_W
    integer(kind=i_def), dimension(undf_pid) :: panel_edge_dist_E
    integer(kind=i_def), dimension(undf_pid) :: panel_edge_dist_S
    integer(kind=i_def), dimension(undf_pid) :: panel_edge_dist_N

    real(kind=r_tran),   allocatable :: x(:)
    real(kind=r_tran),   allocatable :: y(:)
    real(kind=r_tran),   allocatable :: field_x(:)
    real(kind=r_tran),   allocatable :: field_y(:)
    real(kind=r_tran),   allocatable :: field_tmp(:)
    real(kind=r_tran),   allocatable :: increment_x(:)
    real(kind=r_tran),   allocatable :: increment_y(:)
    integer(kind=i_def), allocatable :: stencil_map_x(:,:)
    integer(kind=i_def), allocatable :: stencil_map_y(:,:)

    real(kind=r_tran)   :: dep_disp
    integer(kind=i_def) :: monotone
    integer(kind=i_def) :: stencil_size
    integer(kind=i_def) :: stencil_size_x
    integer(kind=i_def) :: stencil_size_y
    integer(kind=i_def) :: extent_size
    integer(kind=i_def) :: undf_wf

    map_w2(:) = (/ 1, 2, 3, 4 /)
    map_wf(1) = 1
    map_pid(1) = 1

    ! Set no monotonicity
    monotone = monotone_none

    ! Get correct tolerance
    if ( r_tran == real64 ) then
      use_tol = tol
    else
      use_tol = 1.0e-6_r_tran
    end if

    ! Always keep these zero
    panel_edge_dist_S(:) = -ABS(IMDI)
    panel_edge_dist_N(:) = -ABS(IMDI)

    ! TEST 1: Fractional dep dist, positive dep dists --------------------------
    ! Panel edge but no rotation (edge between cells 1 and 2)
    ! Stencil extent of 2

    ! Stencil map has form
    !         | 9 |
    !         | 8 |
    ! | 3 | 2 | 1 | 6 | 7 |
    !         | 4 |
    !         | 5 |

    panel_id(:) = 2.0_r_def
    panel_edge_dist_W(:) = 1
    panel_edge_dist_E(:) = -ABS(IMDI)

    stencil_size = 9
    undf_wf = ndf_wf*nlayers*stencil_size
    stencil_size_x = stencil_size
    stencil_size_y = stencil_size
    extent_size = (stencil_size-1)/4

    allocate(field_x(undf_wf))
    allocate(field_y(undf_wf))
    allocate(field_tmp(undf_wf))
    allocate(increment_x(undf_wf))
    allocate(increment_y(undf_wf))
    allocate(x(undf_wf))
    allocate(y(undf_wf))
    allocate(stencil_map_x(ndf_wf,stencil_size))
    allocate(stencil_map_y(ndf_wf,stencil_size))

    ! Set up maps
    stencil_map_x(1,:) = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /)
    stencil_map_y(1,:) = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /)

    x = (/ 0.0_r_tran, -1.0_r_tran, -2.0_r_tran, &
           0.0_r_tran, 0.0_r_tran, 1.0_r_tran, &
           2.0_r_tran, 0.0_r_tran, 0.0_r_tran /)
    y = (/ 0.0_r_tran, 0.0_r_tran, 0.0_r_tran, &
           1.0_r_tran, 2.0_r_tran, 0.0_r_tran, &
           0.0_r_tran, -1.0_r_tran, -2.0_r_tran /)

    ! Set up field y and field_x to be cubic in the appropriate directions
    field_y(:) = (x(:) - 3.0_r_tran)**3
    field_x(:) = (3.0_r_tran*y(:) - 2.0_r_tran)**3

    ! Initialise increment to zero before each test
    increment_x = 0.0_r_tran
    increment_y = 0.0_r_tran

    ! Test with positive fractional departure distance
    dep_disp = 0.25_r_tran
    dep_pts_xy(:) = (/ dep_disp, 0.0_r_tran, dep_disp, 0.0_r_tran /)

    call horizontal_cubic_sl_sphere_code( nlayers,           &
                                          increment_x,       &
                                          increment_y,       &
                                          field_x,           &
                                          stencil_size_x,    &
                                          stencil_map_x,     &
                                          field_y,           &
                                          stencil_size_y,    &
                                          stencil_map_y,     &
                                          dep_pts_xy,        &
                                          panel_id,          &
                                          panel_edge_dist_W, &
                                          panel_edge_dist_E, &
                                          panel_edge_dist_S, &
                                          panel_edge_dist_N, &
                                          monotone,          &
                                          extent_size,       &
                                          ndf_wf,            &
                                          undf_wf,           &
                                          map_wf,            &
                                          ndf_w2,            &
                                          undf_w2,           &
                                          map_w2,            &
                                          ndf_pid,           &
                                          undf_pid,          &
                                          map_pid )

    ! Test increment
    answer = (-dep_disp - 3.0_r_tran)**3 - field_y(1)
    @assertEqual(answer, increment_x(1), use_tol)

    ! TEST 2: Fractional dep dist, negative dep dists --------------------------
    ! Rotated panel to E (boundary between cells 6 and 7)
    panel_id(:) = 2.0_r_def
    panel_edge_dist_W(:) = -ABS(IMDI)
    panel_edge_dist_E(:) = 2

    ! Swap some values of field_x and field_y to test panel edge calculation
    field_tmp(7) = field_y(7)
    field_y(7) = field_x(7)
    field_x(7) = field_tmp(7)

    ! Initialise increment to zero before each test
    increment_x = 0.0_r_tran
    increment_y = 0.0_r_tran

    ! Test with negative fractional departure distance
    dep_disp = -0.25_r_tran
    dep_pts_xy(:) = (/ dep_disp, 0.0_r_tran, dep_disp, 0.0_r_tran /)

    call horizontal_cubic_sl_sphere_code( nlayers,           &
                                          increment_x,       &
                                          increment_y,       &
                                          field_x,           &
                                          stencil_size_x,    &
                                          stencil_map_x,     &
                                          field_y,           &
                                          stencil_size_y,    &
                                          stencil_map_y,     &
                                          dep_pts_xy,        &
                                          panel_id,          &
                                          panel_edge_dist_W, &
                                          panel_edge_dist_E, &
                                          panel_edge_dist_S, &
                                          panel_edge_dist_N, &
                                          monotone,          &
                                          extent_size,       &
                                          ndf_wf,            &
                                          undf_wf,           &
                                          map_wf,            &
                                          ndf_w2,            &
                                          undf_w2,           &
                                          map_w2,            &
                                          ndf_pid,           &
                                          undf_pid,          &
                                          map_pid )

    ! Test increment
    answer = (-dep_disp - 3.0_r_tran)**3 - field_y(1)
    @assertEqual(answer, increment_x(1), use_tol)

    deallocate(x)
    deallocate(y)
    deallocate(field_x)
    deallocate(field_y)
    deallocate(field_tmp)
    deallocate(increment_x)
    deallocate(increment_y)
    deallocate(stencil_map_x)
    deallocate(stencil_map_y)

    ! TEST 3: Integer dep dist, positive dep dists -----------------------------
    ! Stencil extent of 3, panel rotation
    panel_id(:) = 1.0_r_def
    panel_edge_dist_W(:) = 1
    panel_edge_dist_E(:) = -ABS(IMDI)

    stencil_size = 13
    undf_wf = ndf_wf*nlayers*stencil_size
    stencil_size_x = stencil_size
    stencil_size_y = stencil_size
    extent_size = (stencil_size-1)/4

    allocate(field_x(undf_wf))
    allocate(field_y(undf_wf))
    allocate(field_tmp(undf_wf))
    allocate(increment_x(undf_wf))
    allocate(increment_y(undf_wf))
    allocate(x(undf_wf))
    allocate(y(undf_wf))
    allocate(stencil_map_x(ndf_wf,stencil_size))
    allocate(stencil_map_y(ndf_wf,stencil_size))

    ! Set up maps
    stencil_map_x(1,:) = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 /)
    stencil_map_y(1,:) = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 /)

    x = (/ 0.0_r_tran, -1.0_r_tran, -2.0_r_tran, -3.0_r_tran, &
           0.0_r_tran, 0.0_r_tran, 0.0_r_tran, &
           1.0_r_tran,  2.0_r_tran, 3.0_r_tran, &
           0.0_r_tran, 0.0_r_tran, 0.0_r_tran /)
    y = (/ 0.0_r_tran, 0.0_r_tran, 0.0_r_tran, 0.0_r_tran, &
           1.0_r_tran, 2.0_r_tran, 3.0_r_tran, &
           0.0_r_tran, 0.0_r_tran, 0.0_r_tran, &
           -1.0_r_tran, -2.0_r_tran, -3.0_r_tran /)

    ! Set up field y and field_x to be cubic in the appropriate directions
    field_y(:) = (0.5_r_tran*x(:) - 3.0_r_tran)**3
    field_x(:) = (3.0_r_tran*y(:) - 2.0_r_tran)**3

    ! Put panel edge 1 cell away from this column
    panel_id(:) = 4.0_r_def
    panel_edge_dist_W(:) = 1

    ! Swap some values of field_x and field_y to test panel edge calculation
    field_tmp(2:4) = field_y(2:4)
    field_y(2:4) = field_x(2:4)
    field_x(2:4) = field_tmp(2:4)

    ! Initialise increment to zero before each test
    increment_x = 0.0_r_tran
    increment_y = 0.0_r_tran

    ! Test with positive integer departure distance
    dep_disp = 1.25_r_tran
    dep_pts_xy(:) = (/ dep_disp, 0.0_r_tran, dep_disp, 0.0_r_tran /)

    call horizontal_cubic_sl_sphere_code( nlayers,           &
                                          increment_x,       &
                                          increment_y,       &
                                          field_x,           &
                                          stencil_size_x,    &
                                          stencil_map_x,     &
                                          field_y,           &
                                          stencil_size_y,    &
                                          stencil_map_y,     &
                                          dep_pts_xy,        &
                                          panel_id,          &
                                          panel_edge_dist_W, &
                                          panel_edge_dist_E, &
                                          panel_edge_dist_S, &
                                          panel_edge_dist_N, &
                                          monotone,          &
                                          extent_size,       &
                                          ndf_wf,            &
                                          undf_wf,           &
                                          map_wf,            &
                                          ndf_w2,            &
                                          undf_w2,           &
                                          map_w2,            &
                                          ndf_pid,           &
                                          undf_pid,          &
                                          map_pid )

    ! Test increment
    answer = (-0.5_r_tran*dep_disp - 3.0_r_tran)**3 - field_y(1)
    @assertEqual(answer, increment_x(1), use_tol)

    deallocate(x)
    deallocate(y)
    deallocate(field_x)
    deallocate(field_y)
    deallocate(field_tmp)
    deallocate(increment_x)
    deallocate(increment_y)
    deallocate(stencil_map_x)
    deallocate(stencil_map_y)

  end subroutine horizontal_cubic_sl_sphere_kernel_test

end module horizontal_cubic_sl_sphere_kernel_mod_test
